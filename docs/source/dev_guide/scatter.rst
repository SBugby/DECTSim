Scattering
==========

To do scattering, no new classes are made, only functions relying on all the previous classes are used.

Convolutional Scattering
------------------------

This type of scatter uses the same method as the scatter presented in the `XCIST paper <https://dx.doi.org/10.1088/1361-6560/ac9174>`_, and the kernel for the convolution has been retrieved from `XCIST GitHub <https://github.com/xcist/main/tree/master/gecatsim/scatter>`_. 

.. function:: convolutional_scatter(xray_source, photon_count, detector, sfactor)

    :param xray_source: The xray_source used to create the photon count array.
    :param photon_count: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], generated by ray tracing the source through the phantom.
    :param detector: The detector used to create the photon count array.
    :param sfactor: A scatter factor used to customise the amount of scatter in the image.
    :type xray_source: source
    :type photon_count: double
    :type detector: detector
    :type sfactor: double

    :return: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], representing the scatter in the image.

    This method, takes in the photon count across all energy bins and applies a convolution to this array, the result is then added to the original photon count array to create the final count.

To retrieve the scatter kernel, the user can use the following function.

.. function:: get_scatter_kernel()

    :return: A 2D array of dimensions [65, 49], representing the scatter kernel.

    Since the data is retrieved from the file taken from the `xcist` repository, the data needs to be reshaped to column major order, as the data is stored in row major order.

To normalise the photon count, we calculate what the count would be if there was no phantom, an air scan. This function is not limited to the convolutional scatter, it can be used by the user to calculate the air scan, if they so wish.

.. function:: air_scan(xray_source, detector)

    :param xray_source: The xray_source to be used to create the photon count array.
    :param detector: The detector to be used to create the photon count array.
    :type xray_source: source
    :type detector: detector

    :return: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], representing the air scan.

    This function assumes that the ray length provided by the detector array is the exact length between the source and the detector, therefore calculates the total attenuation without performing any ray tracing, using :math:`\mu_a\,l`, where :math:`\mu_a` is the linear attenuation coefficient of air and :math:`l` is the length of the ray.

Monte Carlo Scatter
-------------------

This scatter method is still under development and may be subject to change.
The method is takes a more deterministic approach to scatter than true monte carlo methods, where we rely on the rays generated for ray tracing, and then sample the scatter from these rays. 

We sample every ray at 0.1 mean free paths, and then trace ``100*sfactor`` rays from this point, randomly choosing the direction of the scatter, and the energy of the scattered ray. We then calculate if this ray will hit the detector, and if it does, we add the number of photons that will hit this pixel to the scatter array.

We determine the number of photons that will hit the pixel by using the attenuation of the up to this sample point, the probability of the ray scattering at this point, the number of rays being sampled from this point, and the attenuation of the ray from this point to the detector.

There are several functions involved in this method, but the main function is the following.

.. function:: monte_carlo_scatter(xray_source, phantom, detector_obj, sfactor)

    :param xray_source: The source of xrays to be used to create the scatter.
    :param phantom: The phantom that the rays will be scattered through.
    :param detector_obj: The detector that the rays will be scattered to.
    :param sfactor: A scatter factor used to customise the amount of rays traced and potentially scattered.
    
    :type xray_source: source
    :type phantom: voxel_array
    :type detector_obj: detector
    :type sfactor: double

    :return: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], representing the scatter in the image.

    This function is very similar to :func:`compute_sinogram`, with the only real difference being that this function is used to calculate the scatter, and not the sinogram. This also means that the energy that the rays are scattered with is not the same as the energy that the rays are generated with, and so we need to keep track of this.

.. function:: compton_dist(nrjs)

    :param nrjs: A list of energies to be used to sample the scatter.
    :type nrjs: 1xN double

    :return: :code:`thetas` A list of thetas produced by sampling the distribution using the `Geant4 physics reference manual <https://geant4-userdoc.web.cern.ch/UsersGuides/PhysicsReferenceManual/html/electromagnetic/gamma_incident/compton/compton.html>`_. Used alongside the :func:`compton_scatter` function. The produced thetas should be randomly sampled to produce the angles of scatter.


.. function:: compton_scatter(direction, inrj, thetas)

    :param direction: The initial direction of the ray.
    :param inrj: The initial energy of the ray.
    :param thetas: A list of thetas to be used to sample the scatter.

    :type direction: 3x1 double
    :type inrj: double
    :type thetas: 1xN double

    :return:
        - **direction** (:class:`3x1 double`) - The new direction of the ray after scattering.
        - **nrj** (:class:`double`) - The new energy of the ray after scattering.

    This function calculates the new direction and energy of the ray after a compton scatter. The sampling of the new direction is done using the formulae from the `Geant4 physics reference manual <https://geant4-userdoc.web.cern.ch/UsersGuides/PhysicsReferenceManual/html/electromagnetic/gamma_incident/compton/compton.html>`_ and assisted by the `Geant4 source code <https://github.com/Geant4/geant4/blob/master/source/processes/electromagnetic/lowenergy/src/G4PenelopeComptonModel.cc>`_. 

    This function uses some code directly from CLHEP to calculate the `vector transformation <https://apc.u-paris.fr/~franco/g4doxy4.10/html/_three_vector_8cc_source.html#l00072>`_ in order to retrieve the new direction of the ray. 