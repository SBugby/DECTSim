Scattering
==========

To do scattering, no new classes are made, only functions relying on all the previous classes are used.

Convolutional Scattering
------------------------

This type of scatter uses the same method as the scatter presented in the `XCIST paper <https://dx.doi.org/10.1088/1361-6560/ac9174>`_, and the kernel for the convolution has been retrieved from `XCIST GitHub <https://github.com/xcist/main/tree/master/gecatsim/scatter>`_. 

.. function:: convolutional_scatter(xray_source, photon_count, detector, sfactor)

    :param xray_source: The xray_source used to create the photon count array.
    :param photon_count: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], generated by ray tracing the source through the phantom.
    :param detector: The detector used to create the photon count array.
    :param sfactor: A scatter factor used to customise the amount of scatter in the image.
    :type xray_source: source
    :type photon_count: double
    :type detector: detector
    :type sfactor: double

    :return: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], representing the scatter in the image.

    This method, takes in the photon count across all energy bins and applies a convolution to this array, the result is then added to the original photon count array to create the final count.

To retrieve the scatter kernel, the user can use the following function.

.. function:: get_scatter_kernel()

    :return: A 2D array of dimensions [65, 49], representing the scatter kernel.

    Since the data is retrieved from the file taken from the `xcist` repository, the data needs to be reshaped to column major order, as the data is stored in row major order.

To normalise the photon count, we calculate what the count would be if there was no phantom, an air scan. This function is not limited to the convolutional scatter, it can be used by the user to calculate the air scan, if they so wish.

.. function:: air_scan(xray_source, detector)

    :param xray_source: The xray_source to be used to create the photon count array.
    :param detector: The detector to be used to create the photon count array.
    :type xray_source: source
    :type detector: detector

    :return: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], representing the air scan.

    This function assumes that the ray length provided by the detector array is the exact length between the source and the detector, therefore calculates the total attenuation without performing any ray tracing, using :math:`\mu_a\,l`, where :math:`\mu_a` is the linear attenuation coefficient of air and :math:`l` is the length of the ray.

Monte Carlo Scatter
-------------------

This scatter method is still under development and is not reliable for extensive use. The method is extremely rudimentary, where we rely on the rays generated for ray tracing, and then see where a number of these rays may scatter to. 

There are several functions involved in this method, but the main function is the following.

.. function:: monte_carlo_scatter(xray_source, voxels, detector_obj, sfactor)

    :param xray_source: The source of xrays to be used to create the scatter.
    :param voxels: The phantom that the rays will be scattered through.
    :param detector_obj: The detector that the rays will be scattered to.
    :param sfactor: A scatter factor used to customise the amount of rays traced and potentially scattered.
    
    :type xray_source: source
    :type voxels: voxel_array
    :type detector_obj: detector
    :type sfactor: double

    :return: An array of dimensions [energy_bins, ny_pix, nz_pix, nrotation], representing the scatter in the image.

    This function is very similar to :func:`compute_sinogram`, with the only real difference being that the function used to calculate the attenuation, instead :func:`calculate_scatter` is used. Also, as we know that the rays may not have the same energy or appear in the same place as the original rays, we need to keep track of these with linear indexing, so we can then non linearly index the scatter array (for parallelisation purposes).

.. function:: calculate_scatter (n_mfp, ls, idxs, ray_start, ray_dir, ray_len, nrj, prev_mu, num_scatter, mu_arr, mfp_arr, voxels, ray_tracing)

    :param n_mfp: The number of mean free paths that this particular ray will have before it scatters. (Use :math:`-\ln(\xi)` where :math:`\xi` is a random number between 0 and 1).
    :param ls: The lengths in each voxel that the ray has been ray traced through.
    :param idxs: The indices of the voxels that the ray has been ray traced through.
    :param ray_start: The starting point of the ray.
    :param ray_dir: The direction of the ray.
    :param ray_len: The length of the ray.
    :param nrj: The energy of the ray.
    :param prev_mu: The previous linear attenuation coefficient of the ray. (Set to 0 if this is the first scatter).
    :param num_scatter: The number of times the ray has scattered.
    :param mu_arr: The linear attenuation coefficients of the voxels.
    :param mfp_arr: The mean free paths of the voxels.
    :param voxels: The phantom that the ray is being scattered through.
    :param ray_tracing: The ray tracing function to be used to trace the ray through the phantom.

    :type n_mfp: double
    :type ls: 1xN double
    :type idxs: 3xN double
    :type ray_start: 3x1 double
    :type ray_dir: 3x1 double
    :type ray_len: double
    :type nrj: double
    :type prev_mu: double
    :type num_scatter: double
    :type mu_arr: 1xN double
    :type mfp_arr: 1xN double
    :type voxels: voxel_array
    :type ray_tracing: function

    :return:
        - **ray_start** (:class:`3x1 double`) - The starting point of the final scattered ray (if it has scattered), otherwise the same as the input.
        - **ray_dir** (:class:`3x1 double`) - The direction of the final scattered ray (if it has scattered), otherwise the same as the input.
        - **mu** (:class:`double`)-  The total linear attenuation coefficient of the ray after scattering
        - **num_scatter** (:class:`double`) - The number of times the ray has scattered.
        - **scattered** (:class:`logical`) - A boolean representing whether the ray has scattered or not.
    
    This method is slightly flawed in it's approach to scattering, first only compton interactions are considered, and secondly, we continue to track the attenuation of the ray, however, this implies that if this ray is used alongside the Beers-Lambert law, we are assuming that this scattered ray represents many rays, which is not the case. This method is still under development and is not reliable for extensive use. Once sources with reliable intensities have been implemented, this method will be revisited.

    To determine whether a ray should scatter, we calculate a random number of mean free paths that the ray will take. Where :math:`l_m = -\ln(\xi)`, where :math:`\xi` is a random number between 0 and 1. Then using the :func:`cross_section` and :func:`mean_free_path` functions, we can calculate the true number of mean free paths that the ray will take. At the point that the random number of mean free paths is equal to the true number of mean free paths, the ray will scatter.

    Once we know the point at which our ray will scatter, we need to calculate the new direction of the ray, and the new energy of the ray. This is done using the :func:`compton_scatter` function. Then we recalculate the linear attenuation coefficient of the ray, from this new point in the new direction with the new energy using the :func:`ray_tracing` function, before recursively calling the :func:`calculate_scatter` function again.

    The function will continue to call itself until the ray has reaches the end of the tracing length, without scattering, or if the ray no longer intersects the phantom. 

.. function:: compton_scatter(direction, inrj)

    :param direction: The initial direction of the ray.
    :param inrj: The initial energy of the ray.

    :type direction: 3x1 double
    :type inrj: double

    :return:
        - **direction** (:class:`3x1 double`) - The new direction of the ray after scattering.
        - **nrj** (:class:`double`) - The new energy of the ray after scattering.

    This function calculates the new direction and energy of the ray after a compton scatter. The sampling of the new direction is done using the formulae from the `Geant4 physics reference manual <https://geant4-userdoc.web.cern.ch/UsersGuides/PhysicsReferenceManual/html/electromagnetic/gamma_incident/compton/compton.html>`_ and assisted by the `Geant4 source code <https://github.com/Geant4/geant4/blob/master/source/processes/electromagnetic/lowenergy/src/G4PenelopeComptonModel.cc>`_. 

    This function uses some code directly from CLHEP to calculate the `vector transformation <https://apc.u-paris.fr/~franco/g4doxy4.10/html/_three_vector_8cc_source.html#l00072>`_ in order to retrieve the new direction of the ray. 